> 제목 : Chapter 12. Execution
>
> 글쓴이 : James Gosling, Bill Joy, Guy Steele, Gilad Bracha, Alex Buckley
>
> 출처 : https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html

>  요약

>  자바 프로그램을 실행하면 클래스 로드 -> 링크 (검증, 준비, resolve) -> 초기화 과정을 거친다



### 12 장. 실행

이 챕터에서는 프로그램을 실행할때 어떤 일이 일어나는지 설명합니다. 이 챕터는 자바가상머신의 라이프사이클과 프로그램을 구성하는 클래스, 인터페이스, 오브젝트를 중심으로 구성되어 있습니다.

자바가상머신은 특정 클래스를 로딩하면서 시작되고 그 특정 클래스 안에 있는 main 메소드를 호출합니다. 12.1 섹션은 이 챕터를 소개하는 내용으로 로딩, 링킹, 메인에 관한 초기화 단계를 설명합니다. 이어지는 세션에서 로딩(12,2), 링킹(12,3), 초기화(12.4)의 세부사항을 명시하고 있습니다.

또 클래스 인스턴스를 생성 절차(12.5)와 소멸 절차(12.6)에 대해 명시합니다. 그리고 클래스 언로딩(12.7)과 프로그램이 종료될 때 진행되는 절차(12.8)에 대해 설명하며 마무리 합니다.



#### 12.1 자바가상머신의 시작

자바가상머신은 특정 클래스의 string 배열을 인자로 받는 main메소드를 호출하면서 실행을 시작합니다. 아래 예에서 볼 수 있듯이 첫번째 클래스 이름은 Test 입니다. JVM 시작에 관한 정확한 의미는 Java Virtual Machine Specification, Java SE 8 Edition Chapter 5를 참조하세요. 여기서는 자바 언어 관점에서 전체 프로세스의 개요만 설명합니다.

어떤 클래스가 이니셜 클래스로 지정되는지는 여기서 설명하지 않습니다, 다만 커맨드라인을 사용하는 환경에서 클래스의 이름을 커맨드 라인 인자로 넘기고 다음 인자들은 main 메소드의 인자들로 넘겨주는 것이 일반적입니다.

> 예를 들어, UNIX 환경에서 다음 커맨드 라인을 입력하면
>
> java Test reboot Bob Dot Enzo
>
> 일반적으로  Test 클래스의 main 메소드에 "reboot", "Bob", "Dot", "Enzo" 네 개의 string을 배열로 담아 인자로 넘기면서 main 메소드를 호출하는 것으로 JVM을 실행 시킬 것입니다.

자 그러면 다음 섹션에서 설명하고 있는 로딩, 링킹, 초기화 과정에 대한 예로 Test 클래스를 실행할 때 자바가상머신에서 일어나는 단계를 간략하게 살펴보겠습니다.



##### 12.1.1 Test 클래스 로드

Test 클래스의 main 메소드를 실행하려는 첫 시도에서 Test 클래스가 로드되어 있지 않다(자바가상머신이 이 클래스에 대한 바이너리를 갖고있지 않다)는 사실을 발견합니다. 자바가상머신은 클래스 로더를 사용해서 바이너리를 찾으려고 시도합니다. 찾지 못하면 에러를 던집니다. 로딩에 관한 설명은 12.2 섹션에 설명되어 있습니다.

##### 12.1.2 Test 링크 : 검증, 준비, (선택적으로) Resolve

Test가 로드된 뒤에는 main 메소드가 실행되기 전에 초기화 되어야 해야합니다. 그리고 초기화되기 전에는 링크되어야 합니다. 링크는 검증, 준비, (선택적인) resolve와 관련이 있습니다. 링크는 12.3 섹션에서 설명합니다.

검증 단계에서는 로딩된 Test가 적절한 심볼 테이블을 사용해서 형식에 맞게 표현되어 있는지 확인합니다. 또 Test를 구현하는 코드가 java 언어와 자바가상머신의 의미 요구사항을 준수하는지 확인합니다. 만약 검증단계에서 문제가 발견되면 에러를 던집니다. 검증은 12.3.1에서 설명하고 있습니다.

준비 단계는 그리고 메소드 테이블 같이 자바가상머신 내부에서 사용되는 자료구조와 정적인 저장공간을 할당하는 것과 관련이 있습니다. 준비 단계는 12.3.2에서 설명합니다.

Resolve 단계는 Test로부터 다른 클래스나 인터페이스로의 심볼릭 참조를 확인하는 과정입니다. 심볼릭 참조를 확인할 때는 Test에 언급된 다른 클래스와 인터페이스를 로딩하고 그 참조가 올바른지 확인합니다.

Resolve 단계는 초기 링크 단계에서 선택적으로 실행됩니다. 한 구현은 막 링크된 클래스나 인터페이스로부터 심볼릭 참조부터 나중에 참조될 클래스나 인터페이스의 심볼릭 참조까지 모두 resolve 합니다. (이 resolution은 나중에 참조될 클래스의 로딩, 링킹 단계에서 에러가 발생할 수 있습니다) 이 구현 선택은 한 극단성을 나타내며(?), C언어에서 단순하게 구현한 static 링크와 유사합니다. (이 구현에서는, 컴파일된 프로그램이 "a.out"  파일로 표현되는데, 프로그램에서 사용되는 라이브러리까지 모두 링크되어있는 상태로, 라이브러리의 복사본까지 "a.out" 파일에 포함되어 있습니다)

다른 구현방식에서는 실제로 사용될 때만 심볼릭 참조를 resolve 합니다. 이 전략을 모든 심볼릭 참조에 대해 지속적으로 사용하면 "laziest"한 형태의 resolution이 됩니다. 이 경우, Test가 다른 클래스에 몇몇 심볼릭 참조를 가지고 있다면, 참조는 실제로 사용될 때 한번만 resolve 될 거나, 프로그램 실행동안 한번도 사용되지 않는다면 아예 resolve 하지 않을 것입니다.

위에서 설명한대로 "static" 한 구현을 사용하면, 프로그램이 실행되기 전에 로딩과 링킹 에러가 발생할 수 있습니다. 만약 Test 클래스에서 참조하고 있거나 참조하고있는 클래스나 인터페이스가 참조하고 있다면요. "laziest"한 구현을 사용하면 이런 에러는 잘못된 심볼릭 참조를 실제로 사용할 때만 던져지게 됩니다.

resolution 과정에 관한 설명은 12.3.3에 나와있습니다. 

##### 12.1.3 Test 초기화 : Initializers 실행

지금까지의 예에 이어서 자바가상머신은 Test 클래스의 main 메소드를 실행하려 하고 있습니다. 그러기 위해서는 초기화가 되어야 합니다. (12.4.1)

초기화는 Test 클래스의 클래스 변수 이니셜라이저나 스태틱 이니셜라이저의 실행으로 구성되어있습니다. Test 가 초기화되기 전에 바로 위의 superclass가 먼저 초기화되어야 하고, 그 super 클래스의 바로 위의 superclass도 초기화 되어야 합니다. Object 클래스가 초기화될 때까지 쭉이요. Object는 superclass가 없으니까요.

만약에 Test 클래스가 Super 라는 이름의 superclass를 가지고 있다면, Test가 초기화되기 전에 superclass가 초기화되어야 합니다. superclass가 초기화되려면 superclass에 대한 클래스 로딩, 검증, 준비 과정이 진행됩니다. 만약 안되어있었다면요. 구현에 따라 superclass에 대한 심볼릭 참조도 resolve 될 것이고 그 참조에 대한 초기화 과정도 순환적으로 계속 진행됩니다.

그래서 초기화 과정에서 Test 클래스 뿐만 아니라 다른 타입에 대한 로딩, 링킹, 초기화 오류가 발생할 수도 있습니다. 

초기화 과정에 대한 설명은 12.4에 나와있습니다.

##### 12.1.4 Test.main 호출

Test 클래스 초기화가 끝난 후에(다른 로딩, 링킹, 초기화가 차례대로 일어나는 동안) 드디어 Test 클래스의 main 메소드가 호출됩니다. 

main 메소드는 반드시 public, static, void로 선언되어야 하고 String 배열 형식의 파라미터를 가져야 합니다. 그래서 다음과 같은 선언이 가능합니다.

> public static void main(String[] args)

> public static void main(String... args)

